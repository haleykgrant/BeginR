---
title: "R Packages"
author: "Haley Grant"
engine: knitr
webr:
  packages: ['tidyverse']
  show-startup-message: true
  autoload-packages: false
---

__What is an R package__

R comes with a lot of great built-in, ready-to-use functions, but there are plenty of other functions that we might want to use that don't come built in to R. You can write your own functions in R if you want, but usually someone else has already written the kind of function you want to use. This is where **R packages** come in.

The following description of R packages comes from [this R Basics Tutorial from R-Ladies Sydney](https://rladiessydney.org/courses/ryouwithme/01-basicbasics-0/).

> A package is a bundle of code that a generous person has written, tested, and then given away. Most of the time packages are designed to solve a specific problem, so they to pull together functions related to a particular data science problem (e.g., data wrangling, visualisation, inference). Anyone can write a package, and you can get packages from lots of different places, but for beginners the best thing to do is get packages from CRAN, the Comprehensive R Archive Network. It's easier than any of the alternatives, and people tend to wait until their package is stable before submitting it to CRAN, so you're less likely to run into problems. You can find a list of all the packages on CRAN [here](https://cran.r-project.org/).

## Installing R Packages

<div style="padding:59.45% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/416743698?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" referrerpolicy="strict-origin-when-cross-origin" style="position:absolute;top:0;left:0;width:100%;height:100%;" title="Installing R packages"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>

::: callout-important
## Note: Installing packages

You should generally only need to install a package **one time** on your computer. Installing packages is just like downloading any other piece of software on your computer; once you've downloaded it once, you have it on your computer unless you delete it.

Installing packages is different from loading packages, which we'll get to next.
:::

## Loading Packages

Just because you installed an R package once, doesn't mean you want to use it for every task you do in R. Because of this, R will only automatically load a small set of default packages when you launch a new session. Other than the small set of default packages, you'll need to tell it if you want to use any additional packages. To load a library that isn't loaded by default, we use the following code:

::: {style="text-align: center;"}
`library(package_name)`
:::

::: {.callout-note collapse="true" icon="false"}
## Note: Argument Names (continued)

Just to reiterate the previous point about argument names, *technically* the argument name used here in the `library()` function is called `package`. This is assumed to be the first argument, and we generally won't utilize any of the other arguments, which allow you to customize how you want to load a library and if you want anything printed when you load it, etc. But again, we could utilize the argument name like so:

`library(package =  package_name)`
:::

Think of installing and loading R packages as similar to using the Microsoft Word application on your computer. Once you have Microsoft Word installed on your computer, you have the software available to you. But that doesn't mean Word is always running on your computer. In order to use Word, you have to open the application. This is essentially what we are doing when we load a library--we're opening it up so we can use it.

::: {.callout-important collapse="true"}
## Note: loading packages

Another reason we don't automatically load all of the packages we've ever installed on our computer is because sometimes different packages have functions that are named the same thing (this is because R is open-source)! When this happens, it can be frustrating to try to figure out which version of the function R is using and requires extra code to tell R which version of the function you want to use. To avoid this it is best practice to only load the packages you currently need.
:::

::: {.callout-important collapse="true"}
## Loading uninstalled packages

Remember that you have to install an R package once before you ever use it. After you've installed it once, you don't need to re-install it, you just need to load it into your session to have access to its contents.

If you ever run a line of code like this:

::: {style="text-align: center;"}
[library(mypackage)]{style="font-family: 'Monaco'; font-weight: 500;"}
:::

and get an error message like this:

::: {style="text-align: center;"}
[Error in library(mypackage) : there is no package called 'mypackage']{style="color: #db4133; font-family: 'Monaco'; font-weight: 500;"}
:::

this means you are trying to load a package you haven't installed yet and you need to run `install.packages("mypackage")` once first.
:::

## The tidyverse package

The R `tidyverse` package is a very useful suite of packages that make data manipulation and visualization clean and efficient. To see all of the packages included in the `tidyverse` package run the following code to print the names of all packages within the `tidyverse` suite:

```{webr-r}
# print the packages contained in the tidyverse
tidyverse_packages()

```

### Error message

Oh no! We got another error message. You should see the following error:

::: {style="text-align: center;"}
[Error: could not find function "tidyverse_packages"]{style="color: #db4133; font-family: 'Monaco'; font-weight: 500;"}
:::

This is R's way of telling you that you're trying to use a function that it doesn't have access to. The `tidyverse_packages()` function comes from the `tidyverse` package. **I have already installed the `tidyverse` for you in the setup of this tutorial, but I didn't load it.**

To give ourselves access to the functions from the `tidyverse` package, let's add the line of code `library(tidyverse)` before the line of code in the chunk above. That should fix the problem.

::: {.callout-note icon="false" appearance="simple"}
#### Exercise:

Add the line of code `library(tidyverse)` before the line of code in the chunk above and try rerunning the code chunk.

::: {.callout-tip collapse="true"}
#### Solution

```{webr-r}
#| message: false
#| warning: false
# first load the library
library(tidyverse)
# print the packages contained in the tidyverse
tidyverse_packages()

```
:::
:::

### The pipe operator from the tidyverse

One of the unique functions provided by the `tidyverse` is called the "pipe operator." The pipe operator looks like this: `%>%`. The pipe operator is a way of stringing together a bunch of functions and the purpose is to make your code easier to read.

::: {.callout-note collapse="true"}
## Note: `%>%` vs `|>`

Recent updates to R also let you use `|>` as the pipe operator, but I'm old so I still use `%>%` ðŸ™‚
:::

To see an example of this, consider the following task:

We want to know how many unique values are contained in the vector `x_vector`.

To do this, we can start by having R tell us the unique values in `x_vector` using `unique(x_vector)`. This will give us a vector of the unique values in `x_vector`. Then, we can print the length of the output of `unique(x_vector)` using the `length()` function. This will print out the number of entries in the vector of unique entries of `x_vector`.

To do this, we can use multiple functions simultaneously by nesting the parentheses:

```{webr-r}
# make a vector with the values -1, 1, 2, 3, 1, 2, 3
x_vector = c(-1, 1, 2, 3, 1, 2, 3)

# take x_vector from earlier, 
# find the unique values,
# then show the length of the unique values to count the number of unique values
length(unique(x_vector))

```

Notice how the order of operations was:

1.  Start with your input `x_vector`

2.  Determine the unique values of `x_vector`

3.  Calculate length of `unique(x_vector)`

However, reading left-to-right we see the last step first. This can get particularly confusing when we want to apply multiple sequential functions to the same object in R. Imagine we had wanted to do 3 more functions! This would have read as:

::: {style="text-align: center;"}
`function3(function2(function1(length(unique(x_vector)))))`
:::

That's a lot of parentheses and it's hard to even figure out where the operation starts! The pipe operator can be helpful in these scenarios. Returning to our example, we can print the number of unique entries of `x_vector` as follows:

```{webr-r}
# same thing as above but with the pipe operator
x_vector %>% unique() %>% length()

```

See how the output is the same but the order of operations is much clearer in this example? It's clear that we start with the object `x_vector`, which we then extract just the unique values from, then finally calculate the length of just the vector of unique values.

In the example above with an extra 3 functions at the end, this would read as:

::: {style="text-align: center;"}
`x_vector %>% unique() %>% length() %>% function1() %>% function2()  %>% function3()`
:::

Still long, but a lot easier to follow (at least I think so)!

